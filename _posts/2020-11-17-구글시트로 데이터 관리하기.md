 
## UGS
 세부링크
 https://cheeseallergyhamster.gitbook.io/unitygooglesheet/
 
 게임 개발을 하며 겪은 데이터 관리의 불편함을 한방에 해소하기 위해 UGS라는 라이브러리를 출시했다. 구글시트에 데이터를 작성하고 JSON으로 파싱해와서 내부에 캐싱하여 사용하는 방식이다. 코드 제네레이터도 지원한다. 일반적이고 당연한거지만, UGS는 구글스프레드시트의 특성을 매우 잘 활용한 툴이다.
 
### UGS만이 가지는 장점
 - 확장코드 작성을통해 C#의 타입에 제약받지 않고 시트를 작성할 수 있다. Primitive 타입은 물론, Custom Class & Struct까지. 프로그래머 마음대로!
 - 유니티 뿐만 아니라 일반 C#애플리케이션에도 사용할 수 있게끔 작성되었다. 
 - 구글드라이브와 연동되는 GoogleDrive Explorer GUI를 제공하므로 Window Explorer, Brwoser를 열어둘 필요가 없다.
 - 구글스프레드 시트의 구조를 잘 활용한 코드 제네레이터를 지원한다.
## 구글시트를 선택한 이유?
 
 - 공동작업이 가능하다는 이유가 가장 크다.
 - 시트에 웹 api로 접근이 가능하다. 
 - 구글 스크립트로 프로그래밍 할 수 있다.
 - 자동으로 버전 기록이 남는다.
 - 브라우저에서 실행되므로 엑셀보다 훨씬 가볍다. 기능도 꿇리지 않는다.
 - 외 고급 기능 작성에 있어서 vba같은 구식되고 어려운 프로그래밍 언어가 필요없다.
 
 ### UGS의 코드제네레이터 규칙
 ![](https://i.imgur.com/5YyWzEz.png)
 
  코드제네레이터를 구현하기전헤 구글시트가 가지는 세부사항을 체크했다.
  엑셀과 똑같다. 스프레드시트의 파일명은 네임스페이스로 사용하고 시트 정보들은
  셀 데이터를 포함하므로 클래스로 사용한다.

  아래와 같은 작성규칙을 적용했다.
 - A열은 데이터의 고유한 키값으로 사용되며 중복되면 안된다.
 - B~Z열은 데이터의 값으로 사용된다.
 - 각 열의 1행은 데이터의 이름과 타입을 지정하는데 사용한다. 기본 형식은 DataName : Type 이다.
 - 각 열의 2행은 데이터가 무엇인지 주석을 지정하는데 사용한다 .
그 외 모든 행에는 키 혹은 값을 입력한다.
 - 스프레드시트의 파일이름은 네임스페이스로 사용한다.
 - 스프레드시트의 하단의 시트이름은 클래스명으로 사용한다. 여러개를 추가해서 사용해도 된다. 

#### 생성된 코드 비교
 ![](https://i.imgur.com/a39d4hU.png)
 이는 위 스프레드시트를 Generate 했을때 생성되는 코드이다.
 - 스프레드시트 정보를 포함한다.
 - 스프레드시트의 어떤 시트인지 ID값을 포함한다.
 - [읽기] Dictionary, List를 포함하며 해당데이터 초기화를 위한 Load함수를 포함한다.
 - [쓰기] Write함수를 사용해서 구글시트에 데이터를 쉽게 쓸 수 있다.



만약 데이터를 읽어오고 싶다면 아래와같이 사용한다.
```cs

/* Generate해둔 캐싱된 Json에서 불러오기 */
DefaultTable.Data.Load(); 
//혹은
UnityGoogleSheet.Load<DefaultTable.Data>(); //보통을 Wrapper를 사용 권장. (위와 같은함수) 
/* 구글 클라우드에서 불러오기. 게임을 다시 빌드하지않아도 구글시트 데이터 기준으로 실시간으로 데이터 로드가 된다. */
UnityGoogleSheet.LoadFromGoogle<int,DefaultTable.Data>((list,map)=>{ }, false);
```
  
데이터를 구글시트에 입력하고 싶은경우는 아래와같이 작성한다.
```cs

DefaultTable.Data.Write(new DefaultTable.Data());
//혹은 아래를 사용한다 (권장)
UnityGoogleSheet.Write(new DefaultTable.Data(){....}); 
```

간단하게 코드 한줄로 읽고 쓰는 모든걸 할 수 있다는게 장점이다.


### 새로운 타입의 추가

구글스프레드 시트에 primitive한 모든 타입은 다 사용할 수 있다. 하지만 Vector3타입, 혹은 List<Vector3> 타입, 아니면 내가 직접 정의한 CustomStruct등의 타입은 어떤식으로 파싱할 수 있을까?

그것을 위해 프로그래머에게 TypeMap에 대한 구현을 강제적으로 요구한다. Read와 Write함수 구현의 강제이다. 예를들어 Vector3 같은 타입은 아래와같이 구현하면된다.

```cs

using UnityEngine; 
namespace Hamster.ZG.Type
{ 
    [Type(typeof(Vector3), new string[] { "vector3", "Vector3", "vec3" })]
    public class Vector3Type : IType
    {
        public object DefaultValue => Vector3.zero;
        /// <summary>
        /// 구글시트의 한 셀에서 읽어온 값은 value 파라미터로 전달된다.
        /// </summary> 
        public object Read(string value)
        {
             // value form : [1,2,3] 
             var values = ReadUtil.GetBracketValueToArray(value);
             float x = float.Parse(values[0]);
             float y = float.Parse(values[1]);
             float z = float.Parse(values[2]); 
             return new Vector3(x,y,z);
        }

        /// <summary>
        /// 현재 객체를 구글시트에 쓸때 형식이다.
        /// </summary> 
        public string Write(object value)
        {
            Vector3 v = (Vector3)value;
            return $"[{v.x},{v.y},{v.z}]";
        }
    }
}
```

아래의 이미지와 같다.

![](https://i.imgur.com/wg9IvVI.png)


**type** : 구글시트 타입에 적을 구분자 스트링
**Read** : 호출되면 value파라미터에 셀값이 전달된다
**Write** : 호출되면 value오브젝트를 string으로 변환하여 구글시트에 작성한다.

### 마치며
 UGS를 만들면서 고민한게 많았다. 최대한 기획자와 프로그래머의 편의성을 고려했다. GoogleDrive Explorer에대한 글을 추가 작성할 계획.